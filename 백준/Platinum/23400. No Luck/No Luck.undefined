#include <bits/stdc++.h>
using namespace std;

struct MergeSortTree {
private:
    int n;
    vector<vector<int> > tree;

    void build(int node, int start_index, int end_index, const vector<int> &arr) {
        if (start_index == end_index) {
            tree[node] = {arr[start_index]};
            return;
        }

        int mid = (start_index + end_index) / 2;
        build(node * 2, start_index, mid, arr);
        build(node * 2 + 1, mid + 1, end_index, arr);

        vector<int> &left = tree[node * 2];
        vector<int> &right = tree[node * 2 + 1];
        tree[node].resize(left.size() + right.size());
        ranges::merge(left, right, tree[node].begin());
    }

    template<class F>
    void visit(int node, int start_index, int end_index, int left, int right, F &&fn) const {
        if (right < start_index || end_index < left) return;

        if (left <= start_index && end_index <= right) {
            fn(tree[node]);
            return;
        }

        int mid = (start_index + end_index) / 2;
        visit(node * 2, start_index, mid, left, right, fn);
        visit(node * 2 + 1, mid + 1, end_index, left, right, fn);
    }

public:
    explicit MergeSortTree(const vector<int> &arr) {
        n = static_cast<int>(arr.size());
        tree.resize(4 * n);
        build(1, 0, n - 1, arr);
    }

    template<class F>
    void for_each_bucket(int left, int right, F &&fn) const {
        visit(1, 0, n - 1, left, right, fn);
    }
};


int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);

    int Y, N;
    cin >> Y >> N;
    vector<int> x(Y);
    for (int i = 0; i < Y; ++i) cin >> x[i];
    MergeSortTree mst(x);

    for (int i = 0; i < N; ++i) {
        int ai, pi, fi;
        cin >> ai >> pi >> fi;
        ai--;

        if (x[ai] >= pi) {
            cout << 0 << '\n';
            continue;
        }

        int left = ai + 1;
        int right = ai + fi;
        if (left > right) {
            cout << 0 << '\n';
            continue;
        }

        long long count = 0;
        mst.for_each_bucket(left, right, [&](const vector<int> &bucket) {
            auto it = ranges::lower_bound(bucket, pi);
            count += bucket.end() - it;
        });

        cout << count << '\n';
    }

    return 0;
}