#include <bits/stdc++.h>
using namespace std;

typedef struct Point {
    double x, y;
} Point;

constexpr double epsilon = 1e-9;

double calculate_distance_square(const Point &a, const Point &b) {
    double dx_value = a.x - b.x;
    double dy_value = a.y - b.y;
    return dx_value * dx_value + dy_value * dy_value;
}

int max_matching(const vector<vector<int> > &adjacency, const int right_size) {
    int stamp, left_size = static_cast<int>(adjacency.size());
    vector<int> matched_list(right_size);
    ranges::fill(matched_list, -1);
    vector<int> visited_right_stamp(right_size);

    function<bool(int)> try_match = [&](const int left_index) -> bool {
        for (int right_index: adjacency[left_index]) {
            if (visited_right_stamp[right_index] == stamp) continue;
            visited_right_stamp[right_index] = stamp;

            int other_left_index = matched_list[right_index];
            if (other_left_index == -1 || try_match(other_left_index)) {
                matched_list[right_index] = left_index;
                return true;
            }
        }
        return false;
    };

    int matched_count = 0;
    for (int left_index = 0; left_index < left_size; left_index++) {
        stamp = left_index + 1;
        if (try_match(left_index)) matched_count++;
    }

    return matched_count;
}

int main() {
    ios_base::sync_with_stdio(false), cin.tie(nullptr);

    int N, M;
    double S, V;
    while (cin >> N >> M >> S >> V) {
        vector<Point> left_vertex(N), right_vertex(M);
        for (auto &[x, y]: left_vertex) cin >> x >> y;
        for (auto &[x, y]: right_vertex) cin >> x >> y;

        double limit_square = S * V * S * V;
        vector<vector<int> > adjacency(N);

        for (int left_index = 0; left_index < N; left_index++) {
            for (int right_index = 0; right_index < M; right_index++) {
                double distance_square = calculate_distance_square(left_vertex[left_index], right_vertex[right_index]);
                if (distance_square <= limit_square + epsilon) {
                    adjacency[left_index].push_back(right_index);
                }
            }
        }
        int matched_count = max_matching(adjacency, M);
        cout << (N - matched_count) << '\n';
    }

    return 0;
}