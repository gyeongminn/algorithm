#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct SegmentTree {
private:
    ll n = 0, mod = 0;

    vector<ll> tree;
    vector<ll> lazy_mul;
    vector<ll> lazy_add;

    SegmentTree() = default;

    ll normalize(ll x) const {
        if (mod == 0) return x;
        x %= mod;
        if (x < 0) x += mod;
        return x;
    }

    ll add_value(ll a, ll b) const {
        if (mod == 0) return a + b;
        a += b;
        if (a >= mod) a -= mod;
        return a;
    }

    ll multiply_value(ll a, ll b) const {
        if (mod == 0) return a * b;
        return (a % mod) * (b % mod) % mod;
    }

    void init(const int size, const ll mod_value) {
        n = size;
        mod = mod_value;

        tree.assign(4 * n, 0);
        lazy_mul.assign(4 * n, 1);
        lazy_add.assign(4 * n, 0);
    }

    void build(const int node, const int start_index, const int end_index, const vector<ll> &arr) {
        if (start_index == end_index) {
            tree[node] = normalize(arr[start_index]);
            return;
        }
        int mid = (start_index + end_index) / 2;
        build(node * 2, start_index, mid, arr);
        build(node * 2 + 1, mid + 1, end_index, arr);
        tree[node] = add_value(tree[node * 2], tree[node * 2 + 1]);
    }

    void apply_affine(const int node, const int start_index, const int end_index, const ll mul, const ll add) {
        ll length = (end_index - start_index + 1);
        ll length_term = (mod == 0 ? length : (length % mod));

        tree[node] = add_value(multiply_value(tree[node], mul), multiply_value(add, length_term));

        lazy_mul[node] = multiply_value(lazy_mul[node], mul);
        lazy_add[node] = add_value(multiply_value(lazy_add[node], mul), add);
    }

    void push(const int node, const int start_index, const int end_index) {
        if (start_index == end_index) {
            lazy_mul[node] = 1;
            lazy_add[node] = 0;
            return;
        }

        if (lazy_mul[node] == 1 && lazy_add[node] == 0) return;

        int mid = (start_index + end_index) / 2;
        apply_affine(node * 2, start_index, mid, lazy_mul[node], lazy_add[node]);
        apply_affine(node * 2 + 1, mid + 1, end_index, lazy_mul[node], lazy_add[node]);

        lazy_mul[node] = 1;
        lazy_add[node] = 0;
    }

    ll range_sum(const int node, const int start_index, const int end_index, const int left, const int right) {
        if (right < start_index || end_index < left) return 0;
        if (left <= start_index && end_index <= right) return tree[node];

        push(node, start_index, end_index);

        int mid = (start_index + end_index) / 2;
        ll sum_left = range_sum(node * 2, start_index, mid, left, right);
        ll sum_right = range_sum(node * 2 + 1, mid + 1, end_index, left, right);
        return add_value(sum_left, sum_right);
    }

    void range_apply(const int node, const int start_index, const int end_index, const int left, const int right, const ll mul, const ll add) {
        if (right < start_index || end_index < left) return;
        if (left <= start_index && end_index <= right) {
            apply_affine(node, start_index, end_index, mul, add);
            return;
        }

        push(node, start_index, end_index);

        int mid = (start_index + end_index) / 2;
        range_apply(node * 2, start_index, mid, left, right, mul, add);
        range_apply(node * 2 + 1, mid + 1, end_index, left, right, mul, add);
        tree[node] = add_value(tree[node * 2], tree[node * 2 + 1]);
    }

public:
    explicit SegmentTree(const int size, const ll mod_value = 0) {
        init(size, mod_value);
    }

    explicit SegmentTree(const vector<ll> &arr, const ll mod_value = 0) {
        init(static_cast<int>(arr.size()), mod_value);
        build(1, 0, n - 1, arr);
    }

    void range_add(const int left, const int right, const ll delta) {
        range_apply(1, 0, n - 1, left, right, 1, normalize(delta));
    }

    void range_mul(const int left, const int right, const ll factor) {
        range_apply(1, 0, n - 1, left, right, normalize(factor), 0);
    }

    void range_set(const int left, const int right, const ll value) {
        range_apply(1, 0, n - 1, left, right, 0, normalize(value));
    }

    ll range_sum(const int left, const int right) {
        return range_sum(1, 0, n - 1, left, right);
    }

    ll point_get(const int index) {
        return range_sum(index, index);
    }
};

void solve() {
    int n, m;
    cin >> n >> m;

    int size = n + m;
    SegmentTree seg(size);

    vector<int> position(n + 1);

    for (int movie = 1; movie <= n; ++movie) {
        position[movie] = m + (movie - 1);
        seg.range_add(position[movie], position[movie], 1);
    }

    int current_top = m - 1;
    for (int query_index = 0; query_index < m; ++query_index) {
        int movie;
        cin >> movie;

        int pos = position[movie];
        ll answer = pos == 0 ? 0 : seg.range_sum(0, pos - 1);
        cout << answer << (query_index + 1 == m ? '\n' : ' ');

        seg.range_add(pos, pos, -1);
        position[movie] = current_top;
        seg.range_add(position[movie], position[movie], 1);
        current_top--;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) solve();

    return 0;
}