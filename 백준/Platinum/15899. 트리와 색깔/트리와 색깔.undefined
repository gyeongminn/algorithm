#include <bits/stdc++.h>
using namespace std;

struct MergeSortTree {
private:
    int n;
    vector<vector<int> > tree;

    void build(int node, int start_index, int end_index, const vector<int> &arr) {
        if (start_index == end_index) {
            tree[node] = {arr[start_index]};
            return;
        }

        int mid = (start_index + end_index) / 2;
        build(node * 2, start_index, mid, arr);
        build(node * 2 + 1, mid + 1, end_index, arr);

        vector<int> &left = tree[node * 2];
        vector<int> &right = tree[node * 2 + 1];
        tree[node].resize(left.size() + right.size());
        ranges::merge(left, right, tree[node].begin());
    }

    template<class F>
    void visit(int node, int start_index, int end_index, int left, int right, F &&fn) const {
        if (right < start_index || end_index < left) return;

        if (left <= start_index && end_index <= right) {
            fn(tree[node]);
            return;
        }

        int mid = (start_index + end_index) / 2;
        visit(node * 2, start_index, mid, left, right, fn);
        visit(node * 2 + 1, mid + 1, end_index, left, right, fn);
    }

public:
    explicit MergeSortTree(const vector<int> &arr) {
        n = static_cast<int>(arr.size());
        tree.resize(4 * n);
        build(1, 0, n - 1, arr);
    }

    template<class F>
    void for_each_bucket(int left, int right, F &&fn) const {
        visit(1, 0, n - 1, left, right, fn);
    }
};

constexpr int mod = 1'000'000'007;
int timer = 0;
vector<vector<int> > graph;
vector<int> in, out;
vector<int> color, euler;

void dfs(const int node, const int parent) {
    in[node] = timer;
    euler[timer] = color[node];
    timer++;

    for (int next: graph[node]) {
        if (next == parent) continue;
        dfs(next, node);
    }

    out[node] = timer - 1;
}


int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);

    int N, M, C;
    cin >> N >> M >> C;
    graph.resize(N + 1);
    in.resize(N + 1);
    out.resize(N + 1);
    color.resize(N + 1);
    euler.resize(N);

    for (int i = 1; i <= N; ++i) cin >> color[i];
    for (int i = 0; i < N - 1; ++i) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    timer = 0;
    dfs(1, 0);
    MergeSortTree mst(euler);

    long long answer = 0;
    for (int i = 0; i < M; ++i) {
        int v, c;
        cin >> v >> c;

        int count = 0;
        mst.for_each_bucket(in[v], out[v], [&](const vector<int> &bucket) {
            count += static_cast<int>(ranges::upper_bound(bucket, c) - bucket.begin());
        });

        answer += count;
        if (answer >= mod) answer %= mod;
    }

    cout << (answer % mod) << '\n';
    return 0;
}