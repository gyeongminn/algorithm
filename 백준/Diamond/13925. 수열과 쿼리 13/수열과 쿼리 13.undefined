#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct SegmentTree {
private:
    ll n = 0, mod = 0;

    vector<ll> tree;
    vector<ll> lazy_mul;
    vector<ll> lazy_add;

    SegmentTree() = default;

    ll normalize(ll x) const {
        if (mod == 0) return x;
        x %= mod;
        if (x < 0) x += mod;
        return x;
    }

    ll add_value(ll a, ll b) const {
        if (mod == 0) return a + b;
        a += b;
        if (a >= mod) a -= mod;
        return a;
    }

    ll multiply_value(ll a, ll b) const {
        if (mod == 0) return a * b;
        return (a % mod) * (b % mod) % mod;
    }

    void init(const int size, const ll mod_value) {
        n = size;
        mod = mod_value;

        tree.assign(4 * n, 0);
        lazy_mul.assign(4 * n, 1);
        lazy_add.assign(4 * n, 0);
    }

    void build(const int node, const int start_index, const int end_index, const vector<ll> &arr) {
        if (start_index == end_index) {
            tree[node] = normalize(arr[start_index]);
            return;
        }
        int mid = (start_index + end_index) / 2;
        build(node * 2, start_index, mid, arr);
        build(node * 2 + 1, mid + 1, end_index, arr);
        tree[node] = add_value(tree[node * 2], tree[node * 2 + 1]);
    }

    void apply_affine(const int node, const int start_index, const int end_index, const ll mul, const ll add) {
        ll length = (end_index - start_index + 1);
        ll length_term = (mod == 0 ? length : (length % mod));

        tree[node] = add_value(multiply_value(tree[node], mul), multiply_value(add, length_term));

        lazy_mul[node] = multiply_value(lazy_mul[node], mul);
        lazy_add[node] = add_value(multiply_value(lazy_add[node], mul), add);
    }

    void push(const int node, const int start_index, const int end_index) {
        if (start_index == end_index) {
            lazy_mul[node] = 1;
            lazy_add[node] = 0;
            return;
        }

        if (lazy_mul[node] == 1 && lazy_add[node] == 0) return;

        int mid = (start_index + end_index) / 2;
        apply_affine(node * 2, start_index, mid, lazy_mul[node], lazy_add[node]);
        apply_affine(node * 2 + 1, mid + 1, end_index, lazy_mul[node], lazy_add[node]);

        lazy_mul[node] = 1;
        lazy_add[node] = 0;
    }

    ll range_sum(const int node, const int start_index, const int end_index, const int left, const int right) {
        if (right < start_index || end_index < left) return 0;
        if (left <= start_index && end_index <= right) return tree[node];

        push(node, start_index, end_index);

        int mid = (start_index + end_index) / 2;
        ll sum_left = range_sum(node * 2, start_index, mid, left, right);
        ll sum_right = range_sum(node * 2 + 1, mid + 1, end_index, left, right);
        return add_value(sum_left, sum_right);
    }

    void range_apply(const int node, const int start_index, const int end_index, const int left, const int right, const ll mul, const ll add) {
        if (right < start_index || end_index < left) return;
        if (left <= start_index && end_index <= right) {
            apply_affine(node, start_index, end_index, mul, add);
            return;
        }

        push(node, start_index, end_index);

        int mid = (start_index + end_index) / 2;
        range_apply(node * 2, start_index, mid, left, right, mul, add);
        range_apply(node * 2 + 1, mid + 1, end_index, left, right, mul, add);
        tree[node] = add_value(tree[node * 2], tree[node * 2 + 1]);
    }

public:
    explicit SegmentTree(const int size, const ll mod_value = 0) {
        init(size, mod_value);
    }

    explicit SegmentTree(const vector<ll> &arr, const ll mod_value = 0) {
        init(static_cast<int>(arr.size()), mod_value);
        build(1, 0, n - 1, arr);
    }

    void range_add(const int left, const int right, const ll delta) {
        range_apply(1, 0, n - 1, left, right, 1, normalize(delta));
    }

    void range_mul(const int left, const int right, const ll factor) {
        range_apply(1, 0, n - 1, left, right, normalize(factor), 0);
    }

    void range_set(const int left, const int right, const ll value) {
        range_apply(1, 0, n - 1, left, right, 0, normalize(value));
    }

    ll range_sum(const int left, const int right) {
        return range_sum(1, 0, n - 1, left, right);
    }

    ll point_get(const int index) {
        return range_sum(index, index);
    }
};

ll N, M;
vector<ll> arr;
vector<tuple<ll, ll, ll, ll> > queries;

void solve() {
    SegmentTree tree = SegmentTree(arr, 1e9 + 7);

    for (auto &[option, x, y, v]: queries) {
        int start = x - 1, end = y - 1;
        switch (option) {
            case 1:
                tree.range_add(start, end, v);
                break;
            case 2:
                tree.range_mul(start, end, v);
                break;
            case 3:
                tree.range_set(start, end, v);
                break;
            case 4:
                cout << tree.range_sum(start, end) << '\n';
                break;
            default: ;
        }
    }
}

void input() {
    cin >> N;
    arr.resize(N);
    for (ll &i: arr) cin >> i;
    cin >> M;
    for (int i = 0; i < M; i++) {
        ll option, x, y, v = 0;
        cin >> option >> x >> y;
        if (option != 4) cin >> v;
        queries.emplace_back(option, x, y, v);
    }
}

int main() {
    input();
    solve();
}